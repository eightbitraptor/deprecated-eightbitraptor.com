--- 
title:      Introduction to Rails Unit Testing
created_at: 2009-05-13 14:14:00.272596 +00:00
layout: default
draft: true
filter:
  - erb
  - textile
--- 
<div class="post_header"><h2><%= link_to_page(@page) %></h2><span class="post_date">Posted on <%= @page.created_at.strftime('%d %B %Y') %></span></div>

Disclaimer: I'm a rails n00b and am writing this mostly for my own benefit while I write tests :) If there are any glaring inacuracies or I'm just Doing It Wrong<small><sup>TM</sup></small> Don't hesitate to email me and scream abuse! (Email in the sidebar)

Rails tests are split into several different types depending on the nature of the code they are testing. By looking in the test folder in the rails project directory there should be 4 folders: fixtures, functional, performance and unit. Lets look at these folders and their contents one by one

Fixtures are normally yaml files that contain 'organised data that you want to test against', you can find these, unsurprisingly, in the fixtures folder. 

I'm not going to talk about these much as I've always been taught that relying on external data like this is a pretty bad idea as tests should be as self contained as possible. In the few times I have tried to use them I found them to be painful to manage and keep relevant.

Also even changing the fixtures slightly can potentially cause tests to fail, thus making your tests brittle and lowering test quality.

The functional folder contains tests that test the logic behind your app. In an MVC app this logic is contained in the Controllers, so it follows that this is where the tests for your Rails controllers will be.

Performance tests live in the performance folder, these are generally used to help test the response times of various parts of your application. I've not touched this yet so I'm going to stop there for now.

Unit Tests are tests that test the smallest testable part of an application, normally an individual method. Unit tests are ideally independant from all other tests, they are designed to isolate and check that a small chunk of code works as expected, we don't care in our unit tests how that unit fits into the rest of the program, just that it operates as we expect it to.

h5. Writing the model

For now I'm going to concentrate on some basic unit tests as that's what I'm writing as we speak :)

In my app I have a simple model called robot. It looks like this

<% coderay :lang => 'ruby', :line_numbers => 'inline' do -%>
class Robot < ActiveRecord::Base
  validates_presence_of :ip_address, :user_agent
  has_many :visits
end
<% end -%>

As we can see it's pretty simple, but there is still some logic there that we want to test, namely that we can't save an instance of this model to the db without the ip_address or the user_agent fields.

To test this we need to create a new instance of Robot in our test and then try and save it with and without the data. We will then assert that the save method returns the correct responses. Sounds simple, and in this case, it is!

<% coderay :lang => 'ruby', :line_numbers => 'inline' do %>
class RobotTest < Test::Unit::TestCase
  def test_should_not_save_robot_without_useragent
    r=Robot.new :ip_address => '0.0.0.0'
    assert !r.save, "Not Saved: No User Agent string"
  end
  
  def test_should_not_save_robot_without_ip_address
    r=Robot.new :user_agent => 'user_agent'
    assert !r.save, "Not Saved: No IP Address given"
  end
end
<% end %>

In this example there are 2 methods, both have descriptive names to aid making sense of our test output. Each test is creating a new instance of Robot but in each case we are missing one of the two required parameters. The real meat of the test is in the next line, the assert statement; in this case we are asserting that the robot was not saved (hence the ! before the r.save declaration) and we are passing it a message that will be output to the terminal when the test fails.

h5. Test Output

<% coderay :lang => 'ruby', :line_numbers => 'inline' do %>
Loaded suite /Users/matthouse/checkouts/bot-monitor/test/unit/robot_test
Started
.... 
Finished in 0.040537 seconds.

4 tests, 4 assertions, 0 failures, 0 errors
<% end %>

What happens when we break the tests? For instance if we edit the model and remove the validation of the ip address. This will cause our test_should_not_save_without_ip_address to fail, and sure enoough:

<% coderay :lang => 'ruby', :line_numbers => 'inline' do %>
    1) Failure:
  test_should_not_save_robot_without_ip_address(RobotTest)
      [/test/unit/robot_test.rb:11:in `test_should_not_save_robot_without_ip_address'
       mocha (0.9.5) lib/mocha/test_case_adapter.rb:69:in `__send__'
       mocha (0.9.5) lib/mocha/test_case_adapter.rb:69:in `run']:
  Not Saved: No IP Address given.
  <false> is not true.
<% end %>

We can see the failure, the test that failed, with the containing class in brackets, this can help us give some context to our tests by naming them sensibly.

We can also see the message that we defined in the test for when that assertion should fail. 

h5. Fixing our broken test

There are 2 main ways that we can fix our broken test: Delete it, which 99% of the time is bad, or adjust it so it works

Our new test should look like this:

<% coderay :lang => 'ruby', :line_numbers => 'inline' do %>
  
<% end %>